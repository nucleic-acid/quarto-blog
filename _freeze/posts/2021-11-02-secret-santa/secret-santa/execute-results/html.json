{
  "hash": "2533d86a4505e13cde18413db999c98c",
  "result": {
    "markdown": "---\ntitle: \"Santa. Secret Santa.\"\nsubtitle: |\n  With \"Spooky Season\" coming to an end, Holiday Season is up next. If you have done Secret Santa rounds before, you might have wondered, what the odds are that someone draws his or her own name from the lots.\ndate: 2021-11-04\ncategories:\n  - python\n  - simulation\nimage: images/gift.png\nimage-alt: \"A drawing of a christmas gift.\"\nengine: knitr\n---\n\n\n\n\n\n## Introduction\nSecret Santa is a game related to the tradition of giving gifts to one another on Christmas, with the twist that you (usually) don't know who gave you the gift. In some regions the game is quite popular and is played in many communities, sports groups, school classes,...\n\nAt the time of writing, there are Wikipedia articles on Secret Santa traditions available in 11 languages. I haven't read all of them, but it is clear, that there are many different variations across the world.\nIn Germany this game is called \"Wichteln\". There's also a variation called \"Schrottwichteln\" where you ought to give something that is worthless to you, but might be of value for someone else.\n\nFor this post I will use the variant that I got to know as the \"classic version\" and will build the **mathematical question** on these rules:\n\n> A group of N participants draws lots from a bucket. On each lot is the name of one participant. Each name is included just once, so that the number of lots matches the number of participants. Each participant draws one lot.\n> If any of the participants draws their own name, the draw is invalid and the whole process has to be repeated.  \n> **Q: What is the probability, that a draw is valid for any group size N?**^[This simple riddle came across my mind, when I was invited to join a *Wichtelgruppe* in 2020. As I couldn't find a convincing intuitive solution and my school combinatorics knwoledge wasn't quite sufficient, I went for a simulation to get a feeling for the numbers. I later discussed this with a friend working in maths, who eventually pointed me to the correct equations to describe the problem properly.]\n\n## What's your intuition?\n\nIf you think about it from an intuitive point of view, there are two contradicting effects:\n\n1. As more people participate, each one has a larger \"pool\" of lots to draw from, so the probability is *lower* to end up with one's own name^[(and vice versa for smaller groups)]\n2. As more players participate, the probability of at least one of them drawing their own name *increases*.^[(and vice versa for smaller groups)]\n\n**Before you continue reading**, think about what your intuition says: Do larger groups have to repeat the drawing more often or less often? If you want, you can leave your comment in the end and let me know if the result surprised you or not! \n\n## Let's do a simulation first\nFirst let's create the functions that perform the necessary simulations of drawings for different group sizes and evaluate the correctness of the draws. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport random\n\nnp.random.seed(1224)\n```\n:::\n\n\n### Basic simulation\n\n`draw_lots()` simply returns a random permutation of a sequence from 1 to the group size.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndef draw_lots(n_people = 5):\n    \"\"\" \n    Takes a number of people and returns the simulated frequency of correct drawing rounds.\n    \n\n    Parameters\n    ----------\n    n_people : int, optional\n        The number of people in a wichtel-round. The default is 5.\n\n    Returns\n    -------\n    Array of people (arange from 0 to n_people).\n    Array of lots (random choices without replacement).\n\n    \"\"\"\n    people = np.arange(n_people)\n    lots = np.random.choice(people,size = len(people), replace=False)  \n    return people, lots\n```\n:::\n\n\n`verify_draft()` checks, whether any of the participants drew herself/himself\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndef verify_draft(people, lots):\n    \"\"\"\n    Take two vectors of equal length and returns a boolean whether the draft was a correct wichtel-draft.\n\n    Parameters\n    ----------\n    people : 1D-Array\n    Array of people (arange from 0 to n_people).\n    \n    lots : 1D-Array\n    Vector of lots (random choices without replacement).\n\n    Returns\n    -------\n    True if the round was valid, false, if not.\n\n    \"\"\"\n\n    # compare participants with the lot they drew\n    check = people == lots\n\n    # check if no one drew the own name\n    valid_round = not any(check)\n\n    # return true or false\n    return valid_round\n```\n:::\n\n  \n`sim_wichteln()` uses the above two functions to simulate multiple draws for a given group and returns the fraction of correct draws.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndef sim_wichteln(n_people = 10, rounds = 100):\n    \"\"\"\n    Simulate rounds drawings of lots for one group of size n_people participants, returns mean fraction of correct drawings.\n\n    Parameters\n    ----------\n    n_people : int, optional\n        Number of participants. The default is 10.\n    rounds : int, optional\n        Number of rounds to simulate. The default is 100.\n\n    Returns\n    -------\n    Float: fraction of correct drafts.\n\n    \"\"\"\n    results = []\n    \n    for i in range(rounds):\n        people, lots = draw_lots(n_people)\n        valid_round = verify_draft(people, lots)\n\n        results.append(valid_round)\n        \n    return np.mean(results)\n```\n:::\n\n\n`sim_groups()` repeatedly calls `sim_wichteln()` with increasing group sizes from 1 to the specified max_group.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndef sim_groups(max_group = 1000, rounds = 1000):\n    \"\"\"\n    Simulate 'rounds' times drawings of lots for all group sizes from 1 to max_group.\n\n    Parameters\n    ----------\n    max_group : int, optional\n        Maximum number of participants. The default is 1000.\n    rounds : int, optional\n        Number of rounds to simulate for each group size. The default is 1000.\n\n    Returns\n    -------\n    pd.DataFrame(): A dataframe containing the group sizes, the simulated rounds for each group size and the fraction of valid draws.\n\n    \"\"\"\n    \n    results_df = pd.DataFrame()\n    \n    for n_people in range(1, max_group):\n        results = sim_wichteln(n_people, rounds)\n        results_df = results_df.append({'people':n_people, 'rounds':rounds, 'valid':results}, ignore_index =True)\n    \n    return results_df\n```\n:::\n\n\nLet's have a look at how the fraction of correct draws is simulated for groups of size 1 to 50, where each group is simulated 100 times:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nfig, ax0 = plt.subplots(1, 1, figsize=(8, 5))\nplt.suptitle(\"Fraction of valid draws from 100 simulated\\nrounds in different group sizes\", fontsize=18, y=0.95)\n\nsns.scatterplot(x = simulated_groups.people, y = simulated_groups.valid, ax=ax0)\nax0.set_xlabel(\"Group size [n people]\")\nax0.set_ylabel(\"Fraction of valid rounds in 100 simulated rounds\")\nsns.despine()\n\nplt.show()\n```\n\n::: {.cell-output-display}\n![](secret-santa_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nAs you can see in the graph, there is at least one outlier: `n = 1` (fraction of 0). But most other values are distributed between `0.3` and `0.5`. The summary statistics of the simulated numbers^[for groups of `n >= 4`, see next chapter for explanation] are:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nprint(simulated_groups[simulated_groups.people > 3].describe())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>           people  rounds      valid\n#> count  46.000000    46.0  46.000000\n#> mean   26.500000   100.0   0.363261\n#> std    13.422618     0.0   0.054977\n#> min     4.000000   100.0   0.230000\n#> 25%    15.250000   100.0   0.330000\n#> 50%    26.500000   100.0   0.365000\n#> 75%    37.750000   100.0   0.390000\n#> max    49.000000   100.0   0.460000\n```\n:::\n:::\n\n\n\n### How are the values distributed?\n\nIs there a trend, as the number of participants grows? To analyse this and to narrow down the distribution, we will now repeat the simulation for a larger max_group size, and we will increase the number of simulated rounds per group. For this we'll use another function `sim_steps()` that calls the previously described functions. For each step a histogram of the resulting fractions of correct draws is plotted, showing a narrowing distribution.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndef sim_steps(max_group = 1000, round_steps = [10, 100, 1000]):\n  \"\"\"\n  Perform the simulation with different simulations per group size.\n\n  Parameters\n  ----------\n max_group : int, optional\n      Maximum number of participants. The default is 1000.\n  rounds : list, optional\n      List with differnt steps of simulaiton rounds.\n\n  Returns\n  -------\n  None. Plots are dynamically generated within the function, no value is returned.\n\n  \"\"\"\n  \n  fig, axes = plt.subplots(len(round_steps), 1, figsize=(8, 5*len(round_steps)), sharex=True)\n  plt.subplots_adjust(hspace=0.5)\n  plt.suptitle(f\"Distribution of the fraction of valid draws\\nin groups of 1 to {max_group} participants\", fontsize=18, y=0.95)\n\n\n  for step, ax in zip(round_steps, axes):\n    sim_df = sim_groups(max_group, step)\n    \n    sns.histplot(sim_df['valid'], ax=ax)\n    ax.set_title(f\"Simulating {step} draws at each group size.\")\n    sns.despine()\n    ax.set_xlabel(f\"Mean fraction: {np.round(sim_df['valid'].mean(), 3)}, SD: {np.round(sim_df['valid'].std(), 3)}.\")\n    \n  plt.show()\n\n  return None\n```\n:::\n\n\nLet's call the new function with increasing orders of magnitude:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nsim_steps(max_group = 1000, round_steps = [10, 100, 1000, 5000])\n```\n\n::: {.cell-output-display}\n![](secret-santa_files/figure-html/simulation-3.png){fig-align='center' width=100%}\n:::\n:::\n\n\nThe stepwise increase demonstrates, that the fraction of correct draws narrows down somewhere around `0.36`. So it seems, that the fraction is not trending towards 1 or 0, but rather approaches a certain value somewhere below `0.4`.\nIf this simulation is sufficiently reliable for you, you can take this figure as an estimate for the next Secret Santa group you participate in and skip the rest.\n\nHowever, if you're into math, you might recognize the direction where this is going: isn't 0.36something close to...yes it is!\n\n## The actual math is beautiful\n\nThe necessary keyword, which describes the underlying math is \"derangements\". By definition, a \"derangement\" is a permutation without fixed points, i.e. no element appears in its previous position. Applied to the example of this post, someone drawing his or her own name would be such a fixed point. Hence, a valid round, where this does not happen, is a proper \"derangement\".\n\n<aside>For the extensive and full representation of the mathematical derivation, please refer to this wikipedia article: [Derangement](https://en.wikipedia.org/wiki/Derangement)</aside>\n\nWhen $n!$ is the factorial of a set of size $n$, then the number of derangements is the *subfactorial* $!n$.\n\nThe number of derangements for a given set of size $n$ can be described as:\n\n$$!n=n!\\cdot\\sum_{i=0}^{n}\\frac{(-1)^i}{i!} \\text{ for } n\\geq 1$$\n\nThe fraction of derangements can then be described as:\n\n$$p_n = \\frac{!n}{n!} = \\sum_{i=0}^{n}\\frac{(-1)^i}{i!}$$\n\nIf you increase $n$ to infinity, $p_n$ asymptotically approaches the following:\n\n$$\\lim_{n \\to \\infty} p_n = \\sum_{i=0}^{\\infty}\\frac{(-1)^i}{i!} = \\frac{1}{e}$$\n\nwhere $e$ is \"Euler's number\"^[~2.718].\n\nThis means that the fraction of valid draws for Secret Santa groups tends towards $\\frac{1}{e}\\sim 0,3678794$. However this only applies for groups of at least 4 people. In smaller communities the numbers are different.\n\nFor groups of size 1 to 10 the fractions of valid derangements are as follows^[due to time constraints I'm taking these numbers from the [German Wikipedia article](https://de.wikipedia.org/wiki/Fixpunktfreie_Permutation) on derangements.]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nffp <- tidyr::tribble(\n  ~n, ~subfactorials, ~factorials, ~fraction,\n  0, 1, 1, 1,\n  1, 0, 1, 0,\n  2, 1, 2, 0.5,\n  3, 2, 6, 0.3333333,\n  4, 9,24, 0.375,\n  5, 44, 120, 0.36666666,\n  6, 265, 720, 0.36805555,\n  7, 1854, 5040, 0.36785714,\n  8, 14833,\t40320,\t0.36788194,\n  9,\t133496,\t362880,\t0.36787918,\n  10,\t1334961,\t3628800,\t0.36787946\n)\n\nffp |>\n  knitr::kable() |>\n  kableExtra::kable_paper()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\" lightable-paper\" style='font-family: \"Arial Narrow\", arial, helvetica, sans-serif; margin-left: auto; margin-right: auto;'>\n <thead>\n  <tr>\n   <th style=\"text-align:right;\"> n </th>\n   <th style=\"text-align:right;\"> subfactorials </th>\n   <th style=\"text-align:right;\"> factorials </th>\n   <th style=\"text-align:right;\"> fraction </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1,0000000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 0,0000000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 0,5000000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 3 </td>\n   <td style=\"text-align:right;\"> 2 </td>\n   <td style=\"text-align:right;\"> 6 </td>\n   <td style=\"text-align:right;\"> 0,3333333 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 4 </td>\n   <td style=\"text-align:right;\"> 9 </td>\n   <td style=\"text-align:right;\"> 24 </td>\n   <td style=\"text-align:right;\"> 0,3750000 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 5 </td>\n   <td style=\"text-align:right;\"> 44 </td>\n   <td style=\"text-align:right;\"> 120 </td>\n   <td style=\"text-align:right;\"> 0,3666667 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 6 </td>\n   <td style=\"text-align:right;\"> 265 </td>\n   <td style=\"text-align:right;\"> 720 </td>\n   <td style=\"text-align:right;\"> 0,3680556 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 7 </td>\n   <td style=\"text-align:right;\"> 1854 </td>\n   <td style=\"text-align:right;\"> 5040 </td>\n   <td style=\"text-align:right;\"> 0,3678571 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 8 </td>\n   <td style=\"text-align:right;\"> 14833 </td>\n   <td style=\"text-align:right;\"> 40320 </td>\n   <td style=\"text-align:right;\"> 0,3678819 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 9 </td>\n   <td style=\"text-align:right;\"> 133496 </td>\n   <td style=\"text-align:right;\"> 362880 </td>\n   <td style=\"text-align:right;\"> 0,3678792 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 10 </td>\n   <td style=\"text-align:right;\"> 1334961 </td>\n   <td style=\"text-align:right;\"> 3628800 </td>\n   <td style=\"text-align:right;\"> 0,3678795 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nAs you can see, for $n=1$, a derangement is impossible. For $n=2$ the fraction is every other game, while for $n=3$ the probability is $\\frac{1}{3}$.\n\n## Summary and comments\n\nIf you're planning on starting a Secret Santa round with infinitely many people, you can expect a valid draw of lots in $\\frac{1}{e}\\sim 0,3678794$.  \n**If you're playing it in groups of at least 4 participants, the probability that no one draws a lot with her or his own name on is roughly 37%, *no matter, how many people participate*.**\n\nThanks for reading! Did this meet your intuition, that you had in the beginning? Leave a reply below if so, but also if *not* so or if you have made different experiences in your Secret Santa rounds!\n",
    "supporting": [
      "secret-santa_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/panelset-0.2.6/panelset.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/panelset-0.2.6/panelset.js\"></script>\n<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}